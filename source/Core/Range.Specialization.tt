<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

// <copyright file="Range.cs" author="Dmitry Kravchenin" email="d.kravchenin@zaaml.com">
//   Copyright (c) Zaaml. All rights reserved.
// </copyright>

// *************************************************************
//
// AutoGenerated
//
// *************************************************************

// ReSharper disable All

using System;
using System.Collections.Generic;
using Zaaml.Core.Extensions;

<#
var typeNames = new List<string>{ "byte", "sbyte", "char", "short", "ushort", "int", "uint", "long", "ulong", "float", "double" };
#>

namespace Zaaml.Core
{
	internal struct RangeMinMax<T>
	{
		public RangeMinMax(T minimum, T maximum)
		{
			Minimum = minimum;
			Maximum = maximum;
		}

		public readonly T Minimum;
		public readonly T Maximum;
	}

	internal static class RangeMinMax
	{
		private static readonly Dictionary<Type, object> Dictionary = new Dictionary<Type, object> 
		{
<#
		foreach (var t in typeNames)
		{
#>
			{ typeof(<#= t #>), new RangeMinMax<<#= t #>>(<#= t #>.MinValue, <#= t #>.MaxValue) },
<#
}
#>
		};

		public static RangeMinMax<T> Get<T>()
		{
			return (RangeMinMax<T>)IDictionaryExtensions.GetValueOrDefault(Dictionary, typeof(T), new RangeMinMax<T>(default(T), default(T)) as object);
		}
	}

	public static partial class Range
	{
<#
foreach (var t in typeNames)
{
#>
		public static Range<<#= t #>> Union(Range<<#= t#>> first, Range<<#= t#>> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Range<<#= t #>> Intersect(Range<<#= t #>> first, Range<<#= t #>> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		public static Range<<#= t #>> Complement(Range<<#= t #>> first, Range<<#= t #>> second)
		{
			return ComplementImpl(first, second).Coerce();
		}

		public static <#= t #> Length(this Range<<#= t #>> range)
		{
			return range.IsEmpty ? default(<#= t #>) : (<#= t #>)(range.Maximum - range.Minimum);
		}

		public static Range<<#= t #>> WithOffset(this Range<<#= t #>> range, <#= t #> offset)
		{
			return range.IsEmpty ? range : new Range<<#= t #>>((<#= t #>) (range.Minimum + offset), (<#= t #>) (range.Maximum + offset)).Coerce();
		}

		public static Range<<#= t #>> WithShrink(this Range<<#= t #>> range, <#= t #> value)
		{
			return range.IsEmpty ? range : new Range<<#= t #>>((<#= t #>) (range.Minimum + value), (<#= t #>) (range.Maximum - value)).Coerce();
		}

		public static Range<<#= t #>> WithExpand(this Range<<#= t #>> range, <#= t #> value)
		{
			return range.IsEmpty ? range : new Range<<#= t #>>((<#= t #>) (range.Minimum - value), (<#= t #>) (range.Maximum + value)).Coerce();
		}

		public static Range<<#= t #>> Create(<#= t #> minimum, <#= t #> maximum)
		{
			return new Range<<#= t #>>(minimum, maximum);
		}

		internal static Range<<#= t #>> CreateMaximumUnbounded(<#= t #> minimum, RangeEndPoint minimumPoint = RangeEndPoint.Closed)
		{
			return new Range<<#= t #>>(minimum, minimumPoint, <#= t #>.MaxValue, RangeEndPoint.Unbounded);
		}

		internal static Range<<#= t #>> CreateMinimumUnbounded(<#= t #> maximum, RangeEndPoint maximumPoint = RangeEndPoint.Closed)
		{
			return new Range<<#= t #>>(<#= t #>.MinValue, RangeEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Range<<#= t #>> Coerce(this Range<<#= t #>> range)
		{
			var minimum = range.MinimumPoint == RangeEndPoint.Unbounded ? <#= t #>.MinValue : range.Minimum;
			var maximum = range.MaximumPoint == RangeEndPoint.Unbounded ? <#= t #>.MaxValue : range.Maximum;

			return new Range<<#= t #>>(minimum, range.MinimumPoint, maximum, range.MaximumPoint);
		}

<#
}
#>
	}
}